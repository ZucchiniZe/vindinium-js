var request = require('request');
var PF = require('pathfinding');
var Promise = require('bluebird');
var spawn = require('child_process').spawn
var Table = require('cli-table')
var colors = require('colors')
var bot;

/*@Desc: Bot constructor.  Creates the bot object and sets starting information for the server.
 *
 */
function Bot(key, mode, url) {
  this.key = key;
  this.mode = mode || 'training';
  this.serverURL = url === undefined ? 'http://vindinium.org' : url;
  this.URL = this.serverURL + '/api/' + this.mode;
  this.counter;
  this.gameStart = true;
  this.freeMines = [];
  this.bot1mines = [];
  this.bot2mines = [];
  this.bot3mines = [];
  this.bot4mines = [];
  this.bots = [];
  this.taverns = [];
  this.enemyBots = [];

  bot = this;
}

/*@Desc: Promise structure that runs each round of the game and then calls itself to continue the loop of playing.
 *
 */
Bot.prototype.runGame = function(){
 // console.log("promise sendREquest");
  bot.sendRequest().then(function(){
 //   console.log("promise parse");
    bot.parseTheData()}).then(function(){
 //     console.log("promise botBrain");
      bot.botBrain()}).then(function(){
 //       console.log("startingOver!");
        bot.runGame()}).catch(function(err) {
          console.log('\n'+colors.bgRed.rainbow(err))
        });
};

/*@Desc: Sends post requests to the server.  Initiates the game, or if the game has already started, sends the player's move and gets
 *the next set of information to be parsed.
 *
 */
Bot.prototype.sendRequest = function (){
  var _this = bot;
  _this.mines = [];
  _this.bots = [];
  _this.taverns = [];
    _this.enemyBots = [];
  return new Promise(function(resolve, reject){
    var _this = bot;
    //console.log("play URL :" +  _this.URL +  " : " + _this.playURL);
    //console.log("going to post first startgame:" + _this.URL + ", " + _this.key);
    if(_this.gameStart === true){
      _this.gameStart = false;
      var map = ['m1', 'm2', 'm3', 'm4', 'm5', 'm6'][Math.floor(Math.random() * 6)]
      request.post({url: _this.URL, form: {key: _this.key, map: map, turns: 100}}, function(err, res, body) {
        _this.data = JSON.parse(body);
        if(_this.mode === 'arena' && _this.key !== 'iopmwjz5') {
          spawn('open', [_this.data.viewUrl]);
        }
        _this.playURL = _this.data.playUrl;
        //console.log("this is playURL and playUrl" + _this.data.playUrl + ":" + _this.playURL);
        resolve();
      })
    }
    else{
      if(_this.data.game.finished !== true){
        request.post({url: _this.data.playUrl, form: {key: _this.key, dir: _this.goDir}}, function(err, res, body){
          // console.log("doh" + _this.data.viewUrl);
          if(body === 'Vindinium - Time out! You must play faster') {
            reject('Timed out');
          } else {
            _this.data = JSON.parse(body);
            resolve();
          }
        })
      } else {
        console.log('\nEnd of match'.red)
      }
    }
  })
};

/*@Desc: Each of the characters organized into their own objects with position, health, mines owned
 *health = current health
 */
Bot.prototype.parseTheData = function (){
 return new Promise(function(resolve, reject){
  var _this = bot;
  _this.freeMines.length = 0;
  _this.bot1mines.length = 0;
  _this.bot2mines.length = 0;
  _this.bot3mines.length = 0;
  _this.bot4mines.length = 0;
  _this.bots.length = 0;
  _this.taverns.length = 0;
  _this.enemyBots.length = 0;

  _this.bot1 = {
    id: _this.data.game.heroes[0].id,
    pos:{
      x: _this.data.game.heroes[0].pos.y,
      y: _this.data.game.heroes[0].pos.x,
    },
    life: _this.data.game.heroes[0].life,
    mineCount: _this.data.game.heroes[0].mineCount,
    gold: _this.data.game.heroes[0].gold,
    spawnPos: _this.data.game.heroes[0].spawnPos
  };
  _this.bot2 = {
    id: _this.data.game.heroes[1].id,
    pos:{
      x: _this.data.game.heroes[1].pos.y,
      y: _this.data.game.heroes[1].pos.x,
    },
    life: _this.data.game.heroes[1].life,
    mineCount: _this.data.game.heroes[1].mineCount,
    gold: _this.data.game.heroes[1].gold,
          spawnPos: _this.data.game.heroes[1].spawnPos

  };
  _this.bot3 = {
    id: _this.data.game.heroes[2].id,
    pos:{
      x: _this.data.game.heroes[2].pos.y,
      y: _this.data.game.heroes[2].pos.x,
    },
    life: _this.data.game.heroes[2].life,
    mineCount: _this.data.game.heroes[2].mineCount,
    gold: _this.data.game.heroes[2].gold,
    spawnPos: _this.data.game.heroes[2].spawnPos

  };
  _this.bot4 = {
    id: _this.data.game.heroes[3].id,
    pos:{
      x: _this.data.game.heroes[3].pos.y,
      y: _this.data.game.heroes[3].pos.x,
    },
    life: _this.data.game.heroes[3].life,
    mineCount: _this.data.game.heroes[3].mineCount,
    gold: _this.data.game.heroes[3].gold,
    spawnPos: _this.data.game.heroes[3].spawnPos

  };
  _this.yourBot = {
  };
  if(_this.data.hero.id === 1){_this.yourBot = _this.bot1}
  if(_this.data.hero.id === 2){_this.yourBot = _this.bot2}
  if(_this.data.hero.id === 3){_this.yourBot = _this.bot3}
  if(_this.data.hero.id === 4){_this.yourBot = _this.bot4}

  /* @DescRepackaging the bot.data so that it is more useful for the students.
   *
   * Bot.data currently holds the information from the JSON file in an object.
   *
   * botN will be an object with the botN's position and health
   *
   * map will be an array with the data for the map.
   *  " " = Walkable
   *  "#" = wall
   *  1 = hero 1
   *  2 = hero 2
   *  3 = hero 3
   *  4 = hero 4
   *  "t" = Tavern
   *  "m" = unoned Mine
   *  "a" "b" "c" "d" = Player Owned Mine by player 1, 2, 3, 4 respectively
   */


  var tempMap = _this.data.game.board.tiles;
  var tempMapSize = _this.data.game.board.size;
  _this.map = [];
  for(var i = 0; i < tempMapSize; i++){
    _this.map.push([]);
  }
  for(var i = 0; i < tempMapSize; i++){
    for(var j = 0; j < tempMapSize; j++){
      _this.map[i].push([]);
    }
  }

  var counter = 0;
  var xPos = 0;
  var yPos = 0;
  for(var i = 0; i < (tempMapSize * tempMapSize * 2); i+=2){
    yPos = counter;
    if(tempMap[i] === "#") {_this.map[xPos][yPos] = "#";}
    if(tempMap[i] === " ") {_this.map[xPos][yPos] = " ";}
    if(tempMap[i] === "[") {_this.map[xPos][yPos] = "t"; _this.taverns.push([yPos, xPos]);}
    if(tempMap[i] === "@") {
      _this.map[xPos][yPos] = tempMap[i+1]; _this.bots.push([yPos, xPos]);
    }
    if(tempMap[i] === "$") {
      if(tempMap[i+1] === "1"){
        _this.map[xPos][yPos] = "a"; _this.bot1mines.push([yPos, xPos]);
      }
      else if(tempMap[i+1] === "2"){
        _this.map[xPos][yPos] = "b"; _this.bot2mines.push([yPos, xPos]);
      }
      else if(tempMap[i+1] === "3"){
        _this.map[xPos][yPos] = "c"; _this.bot3mines.push([yPos, xPos]);
      }
      else if(tempMap[i+1] === "4"){
        _this.map[xPos][yPos] = "d"; _this.bot4mines.push([yPos, xPos]);
      }
      else{
        _this.map[xPos][yPos] = "m"; _this.freeMines.push([yPos, xPos]);
      }
    }
    counter++;
    if(counter === tempMapSize){
      counter = 0;
      xPos++;
    }
  }

     //Creates the map used for path stuff.
     //_this.pathFinderMap = _this.map;
     _this.gridLength = _this.data.game.board.size;
     _this.useThisMap = copy(_this.map);
    // Changes all walkables into 0s and non walkables into 1s
    for(var i = 0; i < _this.gridLength; i++){
      for(var j = 0; j < _this.gridLength; j++){
        if(_this.map[i][j] === ' '){_this.useThisMap[i][j] = 0}
        else{_this.useThisMap[i][j] = 1};

      }
    }



    // This Creates the Console Display
    // console.log(bot.map);
    table = new Table({chars: {'top':'','top-mid':'','top-left':'',
      'top-right':'','bottom':'','bottom-mid':'','bottom-left':'',
      'bottom-right':'','left':'','left-mid':'','mid':'','mid-mid':'','right':'',
      'right-mid':'','middle':' '},
      style: { 'padding-left': 0, 'padding-right': 0 },
      head: ['', 'Life', 'Mines', 'Gold', 'Mine %', 'Crashed', 'ELO']
    })
    console.log('\033[2J');

    mineCount = _this.freeMines.length;
    for(i=1;i<=4;i++) {
      mineCount += _this['bot'+i+'mines'].length
    }

    var totals = {'Total':[0, mineCount, 0]}
    for(i=0;i<4;i++) {
      var hero = bot.data.game.heroes[i]
      var botname = hero.name
      if(hero.name == 'random') botname = 'Random ' + i
      var name = _this.data.hero.id-1 === i ? 'My Bot' : botname
      var obj = {}
      totals['Total'][0] += hero.life
      totals['Total'][2] += hero.gold
      if(typeof hero.elo == 'undefined') hero.elo = 0
      obj[name] = [hero.life, hero.mineCount, hero.gold, ((hero.mineCount / mineCount) * 100).toFixed(2), hero.crashed, hero.elo]
      table.push(obj)
    }
    table.push(totals)
    console.log(table.toString())
    console.log('url:', colors.blue.underline(_this.data.viewUrl))
    console.log("Turn: " + colors.yellow(bot.data.game.turn) + "/" + colors.cyan(bot.data.game.maxTurns));

  resolve();
})};


//Function to deep Copy any array
function copy(o) {
   var out, v, key;
   out = Array.isArray(o) ? [] : {};
   for (key in o) {
       v = o[key];
       out[key] = (typeof v === "object") ? copy(v) : v;
   }
   return out;
}


/*@Desc: Creates a bot.pathfinder method for users that will take the location of two items on the map and return the direction
 * that the chracter should go in order to reach the second object based on A* pathfinding
 *@Params - two arrays - each array must have two ints, equal to the X, Y coordinates on the map. Should be  equal to the [x][y] in the map object.
 */
Bot.prototype.findPath = function(pos1, pos2){
    if(pos1 === undefined || pos2=== undefined) return "none";
    var _this = bot;
    //console.log("pathfinder bot :" + bot);
//     var pathFinderMap = _this.map;


//     // Changes all walkables into 0s and non walkables into 1s
//     for(var i = 0; i < gridLength; i++){
//       for(var j = 0; j < gridLength; j++){
//         if(_this.map[i][j] === ' '){pathFinderMap[i][j] = 0}
//         else{pathFinderMap[i][j] = 1};
//       }
//     }



    var grid = new PF.Grid(_this.gridLength, _this.gridLength, _this.useThisMap);
    grid.setWalkableAt(pos1[0], pos1[1], true);
    grid.setWalkableAt(pos2[0], pos2[1], true);

    //console.log(pos1[0], pos1[1], pos2[0], pos2[1]);
    var finder = new PF.AStarFinder();

    var path = finder.findPath(pos1[0], pos1[1], pos2[0], pos2[1], grid);

      //console.log("length of path: " + path.length);
      //console.log("next spot!" + path[1][0] + ", "+ path[1][1]);
      if (path === null || path === undefined || path.length === 0) {
        //console.log("none found +(");
        _this.pathDir = "none";

      }
      else {
        if(path[1][0] === pos1[0]){
          if(path[1][1] < pos1[1]){
            //console.log("set to north");
            _this.pathDir = "north";
            return "north";
          }
          else{
            //console.log("set to south");
            _this.pathDir = "south";
            return "south";
          }
        }
        else{
          if(path[1][0] > pos1[0]){
            //console.log("set to east");
            _this.pathDir = "east";
            return "east";
          }
          else{
            //console.log("set to west");
            _this.pathDir = "west";
            return "west";
          }
         }
        }


    return _this.pathDir;
    };


/*@Desc: Bot.findDistance method that finds the number of steps that would be required to go from one spot to another
 *@Param: two arrays - each array has the x,y spot for one position
 *@Return: one int - the int is equal to the number of steps to get from one spot to another
 */
Bot.prototype.findDistance = function(pos1, pos2){
    if(pos1 === undefined || pos2 === undefined){
        return "none";
    }
  var _this = bot;
  //var pathFinderMap = _this.map;
  //var gridLength = _this.data.game.board.size;

  // Changes all walkables into 0s and non walkables into 1s
//   for(var i = 0; i < gridLength; i++){
//     for(var j = 0; j < gridLength; j++){
//       if(_this.map[i][j] === ' '){pathFinderMap[i][j] = 0}
//       else{pathFinderMap[i][j] = 1};
//     }
//   }
  //sets the grid and makes the start and end positions walkable
  var grid = new PF.Grid(_this.gridLength, _this.gridLength, _this.useThisMap);
  grid.setWalkableAt(pos1[0], pos1[1], true);
  grid.setWalkableAt(pos2[0], pos2[1], true);

    //console.log(pos1[0], pos1[1], pos2[0], pos2[1]);
  var finder = new PF.AStarFinder();
  var path = finder.findPath(pos1[0], pos1[1], pos2[0], pos2[1], grid);
  if(path === undefined){return false;}
  else if(path.length === 0){return 5000}
  else {return path.length;}
}

Bot.prototype.getNeighbors = function() {
  var x = this.yourBot.pos.x
  var y = this.yourBot.pos.y
  var neighbors = [];
  var grid = new PF.Grid(this.gridLength, this.gridLength, this.useThisMap)

  neighbors.push([y - 1,x]);
  neighbors.push([y,x + 1]);
  neighbors.push([y + 1,x]);
  neighbors.push([y,x - 1]);

  return neighbors
}

module.exports = Bot;
